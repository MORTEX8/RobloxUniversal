-- Silent Aim Script with FOV Circle (Fixed Issues)
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- FOV Circle Drawing (Fixed to always be circular)
local circle = Drawing.new("Circle")
circle.Visible = true
circle.Thickness = 1
circle.Color = Color3.fromRGB(255, 255, 255)
circle.Transparency = 1
circle.Filled = false
circle.NumSides = 64 -- Ensures smooth circle

-- Original Hitbox Expansion Code (Unchanged)
function GetPlayers()
    for _, v in pairs(game:GetChildren()) do
        if v.ClassName == "Players" then
            return v
        end
    end
end

local players = GetPlayers()
local plr = players.LocalPlayer

-- Your original hitbox expansion coroutine (Unchanged)
coroutine.wrap(function()
    while wait(1) do
        for _, v in pairs(players:GetPlayers()) do
            if v.Name ~= plr.Name and v.Character then
                -- Right Leg
                if v.Character:FindFirstChild("RightUpperLeg") then
                    v.Character.RightUpperLeg.CanCollide = false
                    v.Character.RightUpperLeg.Transparency = 10
                    v.Character.RightUpperLeg.Size = Vector3.new(13, 13, 13)
                end
                
                -- Left Leg
                if v.Character:FindFirstChild("LeftUpperLeg") then
                    v.Character.LeftUpperLeg.CanCollide = false
                    v.Character.LeftUpperLeg.Transparency = 10
                    v.Character.LeftUpperLeg.Size = Vector3.new(13, 13, 13)
                end
                
                -- Head
                if v.Character:FindFirstChild("HeadHB") then
                    v.Character.HeadHB.CanCollide = false
                    v.Character.HeadHB.Transparency = 10
                    v.Character.HeadHB.Size = Vector3.new(13, 13, 13)
                end
                
                -- HumanoidRootPart
                if v.Character:FindFirstChild("HumanoidRootPart") then
                    v.Character.HumanoidRootPart.CanCollide = false
                    v.Character.HumanoidRootPart.Transparency = 10
                    v.Character.HumanoidRootPart.Size = Vector3.new(13, 13, 13)
                end
            end
        end
    end
end)()

-- FOV Circle Updater (Fixed to persist when tabbed out)
local function updateFOV()
    -- Get mouse position
    local success, mousePos = pcall(function()
        return UserInputService:GetMouseLocation()
    end)
    
    if not success then
        circle.Visible = false
        return
    end
    
    circle.Position = mousePos
    
    -- Find closest player to crosshair
    local closestPlayer = nil
    local closestDistance = math.huge
    
    for _, player in pairs(players:GetPlayers()) do
        if player ~= plr and player.Character and player.Character:FindFirstChild("Head") then
            local head = player.Character.Head
            local headPos, onScreen = Camera:WorldToViewportPoint(head.Position)
            
            if onScreen then
                local distance = (Vector2.new(headPos.X, headPos.Y) - mousePos).Magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestPlayer = player
                end
            end
        end
    end
    
    -- Calculate FOV circle size
    if closestPlayer and closestPlayer.Character and closestPlayer.Character:FindFirstChild("Head") then
        local head = closestPlayer.Character.Head
        local expandedSize = 13
        
        -- Calculate apparent size on screen
        local headPos = Camera:WorldToViewportPoint(head.Position)
        local edgePos = Camera:WorldToViewportPoint(head.Position + Vector3.new(expandedSize/2, 0, 0))
        local radius = (edgePos - headPos).X
        
        circle.Radius = radius
        circle.Visible = true
    else
        circle.Visible = false
    end
end

-- Update FOV every frame (Fixed to persist when tabbed out)
local connection
connection = RunService.Heartbeat:Connect(function()
    local success = pcall(updateFOV)
    if not success then
        circle.Visible = false
    end
end)

-- Proper cleanup when script ends
game:GetService("UserInputService").WindowFocusReleased:Connect(function()
    -- Don't remove the circle, just hide it temporarily
    circle.Visible = false
end)

game:GetService("UserInputService").WindowFocused:Connect(function()
    -- Restore the circle when window regains focus
    if connection then
        circle.Visible = true
    end
end)

-- Your original silent aim hook remains unchanged below...
local mt = getrawmetatable(game)
local oldNamecall = mt.__namecall
setreadonly(mt, false)

mt.__namecall = newcclosure(function(self, ...)
    local args = {...}
    local method = getnamecallmethod()
    
    if method == "FindPartOnRayWithIgnoreList" and not checkcaller() then
        local closestPlayer = nil
        local closestDistance = math.huge
        
        for _, player in pairs(players:GetPlayers()) do
            if player ~= plr and player.Character and player.Character:FindFirstChild("Head") then
                local head = player.Character.Head
                local distance = (head.Position - Camera.CFrame.Position).Magnitude
                
                if distance < closestDistance then
                    closestDistance = distance
                    closestPlayer = player
                end
            end
        end
        
        if closestPlayer and closestPlayer.Character and closestPlayer.Character:FindFirstChild("Head") then
            args[1] = Ray.new(Camera.CFrame.Position, (closestPlayer.Character.Head.Position - Camera.CFrame.Position).Unit * 1000)
            return oldNamecall(self, unpack(args))
        end
    end
    
    return oldNamecall(self, ...)
end)

setreadonly(mt, true)
